package com.narae.fliwith.src.main.review

import android.content.ActivityNotFoundException
import android.content.Context
import android.content.Intent
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.util.Log
import android.view.LayoutInflater
import android.view.MenuInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.PopupMenu
import androidx.core.content.ContextCompat
import androidx.fragment.app.activityViewModels
import androidx.viewpager2.widget.ViewPager2
import com.kakao.sdk.common.util.KakaoCustomTabsClient
import com.kakao.sdk.share.ShareClient
import com.kakao.sdk.share.WebSharerClient
import com.kakao.sdk.template.model.Button
import com.kakao.sdk.template.model.Content
import com.kakao.sdk.template.model.FeedTemplate
import com.kakao.sdk.template.model.ItemContent
import com.kakao.sdk.template.model.ItemInfo
import com.kakao.sdk.template.model.Link
import com.kakao.sdk.template.model.Social
import com.narae.fliwith.R
import com.narae.fliwith.config.BaseFragment
import com.narae.fliwith.databinding.FragmentReviewDetailBinding
import com.narae.fliwith.src.main.MainActivity
import com.narae.fliwith.src.main.review.models.ReviewDetailData
import com.narae.fliwith.src.main.review.models.ReviewViewModel
import com.narae.fliwith.util.showCustomSnackBar
import com.narae.fliwith.util.userProfileImageConvert
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import java.time.temporal.ChronoUnit

private const val TAG = "ReviewDetailFragment_Ïã∏Ìîº"

class ReviewDetailFragment :
    BaseFragment<FragmentReviewDetailBinding>(FragmentReviewDetailBinding::inflate) {

    private lateinit var mainActivity: MainActivity
    private var reviewId: Int = -1

    private val viewModel: ReviewViewModel by activityViewModels()
    private lateinit var response: ReviewDetailData

    // Ïù¥ÎØ∏ÏßÄ Slider
    private lateinit var reviewSliderAdapter: ReviewSliderAdapter

    override fun onAttach(context: Context) {
        super.onAttach(context)
        mainActivity = context as MainActivity
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        
        init()
        heartStatus()
        back()
        setImageSlider()
        setShareLink()

    }

    private fun setShareLink() {
        // Ïπ¥Ïπ¥Ïò§ Í≥µÏú† ÎßÅÌÅ¨ ÏÉùÏÑ±
        binding.reviewDetailShareIcon.setOnClickListener {
            val defaultFeed = FeedTemplate(
                content = Content(
                    title = viewModel.reviewSpotName.value.toString(),
                    description = viewModel.reviewWriteContent.value.toString(),
                    imageUrl = viewModel.reviewImageUrls.value?.get(0).toString(),
                    link = Link(
                        webUrl = "https://developers.kakao.com",
                        mobileWebUrl = "https://developers.kakao.com",
                        androidExecutionParams = mapOf("reviewId" to "$reviewId"),
                        iosExecutionParams = mapOf("reviewId" to "$reviewId")
                    )
                ),
                buttons = listOf(
                    Button(
                        "Í≤åÏãúÎ¨º ÌôïÏù∏ÌïòÎü¨ Í∞ÄÍ∏∞ ü§©",
                        Link(
                            androidExecutionParams = mapOf("reviewId" to "$reviewId"),
                            iosExecutionParams = mapOf("reviewId" to "$reviewId")
                        )
                    )
                )
            )

            val isKakaoTalkAvailable = ShareClient.instance.isKakaoTalkSharingAvailable(requireContext())

            // Ïπ¥Ïπ¥Ïò§ÌÜ° ÏÑ§ÏπòÏó¨Î∂Ä ÌôïÏù∏
            if (isKakaoTalkAvailable) {
                // Ïπ¥Ïπ¥Ïò§ÌÜ°ÏúºÎ°ú Í≥µÏú†
                ShareClient.instance.shareDefault(requireContext(), defaultFeed) { sharingResult, error ->
                    if (error != null) {
                        Log.e(TAG, "Ïπ¥Ïπ¥Ïò§ÌÜ° Í≥µÏú† Ïã§Ìå®", error)
                    } else if (sharingResult != null) {
                        Log.d(TAG, "Ïπ¥Ïπ¥Ïò§ÌÜ° Í≥µÏú† ÏÑ±Í≥µ ${sharingResult.intent}")
                        startActivity(sharingResult.intent)

                        Log.w(TAG, "Warning Msg: ${sharingResult.warningMsg}")
                        Log.w(TAG, "Argument Msg: ${sharingResult.argumentMsg}")
                    }
                }
            } else {
                // ÏõπÏúºÎ°ú Í≥µÏú†
                val sharerUrl = WebSharerClient.instance.makeDefaultUrl(defaultFeed)
                try {
                    KakaoCustomTabsClient.openWithDefault(requireContext(), sharerUrl)
                } catch (e: UnsupportedOperationException) {
                    Log.e(TAG, "CustomTabs ÏßÄÏõê Î∏åÎùºÏö∞Ï†ÄÍ∞Ä ÏóÜÏäµÎãàÎã§.", e)
                    // CustomTabs ÏßÄÏõê Î∏åÎùºÏö∞Ï†ÄÍ∞Ä ÏóÜÏùÑ Îïå, Í∏∞Î≥∏ Ïõπ Î∏åÎùºÏö∞Ï†ÄÎ°ú Ïó¥Í∏∞
                    try {
                        val intent = Intent(Intent.ACTION_VIEW, Uri.parse(sharerUrl.toString()))
                        startActivity(intent)
                    } catch (e: ActivityNotFoundException) {
                        Log.e(TAG, "Ïù∏ÌÑ∞ÎÑ∑ Î∏åÎùºÏö∞Ï†ÄÍ∞Ä ÏóÜÏäµÎãàÎã§.", e)
                    }
                }
            }
        }
    }

    private fun init() {

        // Î∞õÏïÑÏò® reviewId
        reviewId = arguments?.getInt("reviewId") ?: -1

        // ÏùºÎã® ÏßÄÏö∞Í≥†
        binding.reviewDetailMenuIcon.visibility = View.GONE

        // fetchSelectReview Ìò∏Ï∂ú Î∞è ÏΩúÎ∞±ÏóêÏÑú fetchData Ìò∏Ï∂ú
        viewModel.fetchSelectReview(reviewId) { success ->
            if (success) {
                fetchData()
            } else {
                Log.e(TAG, "Failed to fetch review details")
            }
        }

    }

    private fun heartStatus() {
        viewModel.reviewLikeStatus.observe(viewLifecycleOwner) { isLiked ->
            updateLike(isLiked!!)
        }

        // Ï¢ãÏïÑÏöî Í∞úÏàò Í¥ÄÏ∞∞
        viewModel.reviewLikeCount.observe(viewLifecycleOwner) { count ->
            updateLikeCount(count!!)
        }
    }

    private fun back() {
        binding.reviewDetailBackIcon.setOnClickListener {
            navController.popBackStack()
        }
    }

    private fun setImageSlider() {
        // Ïù¥ÎØ∏ÏßÄ Ïä¨ÎùºÏù¥Îçî ÏÑ§Ï†ï
        reviewSliderAdapter = ReviewSliderAdapter(requireContext(), mutableListOf())
        binding.reviewDetailImageVp.adapter = reviewSliderAdapter
        binding.reviewDetailImageVp.registerOnPageChangeCallback(object : ViewPager2.OnPageChangeCallback() {
            override fun onPageSelected(position: Int) {
                super.onPageSelected(position)
                setCurrentIndicator(position)
            }
        })
    }

    private fun updateLike(isLiked: Boolean) {
        if (isLiked) { // Ï¢ãÏïÑÏöî ÎàÑÎ•∏ ÏÉÅÌÉú ÎùºÎ©¥
            // Ï¢ãÏïÑÏöî Î≤ÑÌäº ÎàÑÎ•¥Î©¥
            binding.reviewHeartImage.setOnClickListener {
                // Ï¢ãÏïÑÏöî Ï∑®ÏÜå ÏÉÅÌÉúÎ°ú
                binding.reviewHeartImageDisable.visibility = View.VISIBLE
                binding.reviewHeartImage.visibility = View.GONE

                viewModel.setReviewLikeStatue(false)
                val count = viewModel.reviewLikeCount.value ?: 0
                viewModel.setReviewLikeCount(count - 1)
                postLikeStatus()
            }
        } else { // Ï¢ãÏïÑÏöî ÎàÑÎ•∏ ÏÉÅÌÉúÍ∞Ä ÏïÑÎãàÎ©¥
            // ÎπÑÏñ¥ ÏûàÎäî Ï¢ãÏïÑÏöî Î≤ÑÌäº ÎàÑÎ•¥Î©¥
            binding.reviewHeartImageDisable.setOnClickListener {
                // Ï¢ãÏïÑÏöî ÏÉÅÌÉúÎ°ú
                binding.reviewHeartImageDisable.visibility = View.GONE
                binding.reviewHeartImage.visibility = View.VISIBLE

                viewModel.setReviewLikeStatue(true)
                val count = viewModel.reviewLikeCount.value ?: 0
                viewModel.setReviewLikeCount(count + 1)
                postLikeStatus()
            }
        }
    }

    private fun updateLikeCount(count: Int) {
        // Ï¢ãÏïÑÏöî Í∞úÏàòÎ•º UIÏóê ÏóÖÎç∞Ïù¥Ìä∏
        binding.reviewHeartCount.text = count.toString()
    }

    private fun postLikeStatus() {
        viewModel.fetchLikeReview(reviewId) { success ->
            if (success) {
                Log.d(TAG, "postLikeStatus: Ï¢ãÏïÑÏöî ÎàÑÎ•¥Í∏∞ ÏÑ±Í≥µ")
            } else {
                Log.e(TAG, "Failed to post review like")
            }
        }
    }

    private fun likeStatus(like: Boolean) {
        if (like) { // true Ïù¥ÎØ∏ Ï¢ãÏïÑÏöî ÎàÑÎ•∏ ÏÉÅÌÉú
            viewModel.setReviewLikeStatue(true)
            binding.reviewHeartImage.visibility = View.VISIBLE
            binding.reviewHeartImageDisable.visibility = View.GONE
        } else {
            viewModel.setReviewLikeStatue(false)
            binding.reviewHeartImage.visibility = View.GONE
            binding.reviewHeartImageDisable.visibility = View.VISIBLE
        }
    }

    private fun fetchData() {
        response = viewModel.reviewDetailData.value?.data!!

        binding.reviewDetailUserName.text = response.nickname

        // profile image
        response.disability?.let { userProfileImageConvert(it, binding.reviewDetailProfileImage) }

        // response.createdAtÍ∞Ä nullÏùº Í≤ΩÏö∞ Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
        val timeCal = response.createdAt?.let { timeCalculate(it) } ?: 0
        binding.reviewDetailTime.text = "$timeCal"
        binding.reviewHeartCount.text = response.likes.toString()

        binding.reviewDetailPlace.text = response.spotName
        binding.reviewDetailContent.text = response.content

        likeStatus(response.like)

        // ÏàòÏ†ï, ÏÇ≠Ï†ú
        if (response.mine) { // ÎÇ¥ Í≤åÏãúÎ¨º
            binding.reviewDetailMenuIcon.visibility = View.VISIBLE
            binding.reviewDetailMenuIcon.setOnClickListener {
                popUpMenu()
            }
            binding.reviewHeartImageDisable.setOnClickListener {
                showCustomSnackBar(requireContext(), binding.root, "ÎÇ¥ Í≤åÏãúÎ¨ºÏùÄ ÌïòÌä∏Î•º ÎàÑÎ•º Ïàò ÏóÜÏñ¥Ïöî üòÇ")
            }
        } else {
            binding.reviewDetailMenuIcon.visibility = View.GONE
        }

        viewModel.setReviewLikeCount(response.likes.toString().toInt())
        viewModel.setSpotName(binding.reviewDetailPlace.text.toString())
        viewModel.setReviewWriteContent(binding.reviewDetailContent.text.toString())
        viewModel.setReviewImageUrls(response.images)
        viewModel.setSpotContentId(response.contentId)
        Log.d(TAG, "fetchData: contentId ${response.contentId}")

        Log.d(TAG, "fetchData: ${binding.reviewDetailPlace.text}, ${binding.reviewDetailContent.text}, ${response.images}")

        // Ïù¥ÎØ∏ÏßÄ Ïä¨ÎùºÏù¥ÎçîÏóê Ïù¥ÎØ∏ÏßÄ URLÎì§ ÏÑ§Ï†ï
        reviewSliderAdapter.setImages(response.images)
        setupIndicators(response.images.size)
    }

    private fun setupIndicators(count: Int) {
        val indicators = arrayOfNulls<ImageView>(count)
        val params = LinearLayout.LayoutParams(
            ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT
        ).apply {
            setMargins(16, 8, 16, 8)
        }

        binding.reviewDetailImageIndicator.removeAllViews()

        for (i in indicators.indices) {
            indicators[i] = ImageView(context).apply {
                setImageDrawable(ContextCompat.getDrawable(requireContext(), R.drawable.review_detail_image_indicator_inactive))
                layoutParams = params
            }
            binding.reviewDetailImageIndicator.addView(indicators[i])
        }
        setCurrentIndicator(0)
    }

    private fun setCurrentIndicator(position: Int) {
        val childCount = binding.reviewDetailImageIndicator.childCount
        for (i in 0 until childCount) {
            val imageView = binding.reviewDetailImageIndicator.getChildAt(i) as ImageView
            if (i == position) {
                imageView.setImageDrawable(
                    ContextCompat.getDrawable(
                        requireContext(),
                        R.drawable.review_detail_image_indicator_active
                    )
                )
            } else {
                imageView.setImageDrawable(
                    ContextCompat.getDrawable(
                        requireContext(),
                        R.drawable.review_detail_image_indicator_inactive
                    )
                )
            }
        }
    }

    private fun popUpMenu() {
        val popupMenu = PopupMenu(requireContext(), binding.reviewDetailMenuIcon, 0, 0, R.style.CustomPopupMenu)
        val inflater: MenuInflater = popupMenu.menuInflater
        inflater.inflate(R.menu.menu_review_detail_popup, popupMenu.menu)
        popupMenu.setOnMenuItemClickListener { menuItem ->
            when (menuItem.itemId) {
                R.id.update -> {
                    // ÏàòÏ†ï
                    val bundle = Bundle()
                    bundle.putInt("reviewId", reviewId)
                    navController.navigate(R.id.action_reviewDetailFragment_to_reviewWriteFragment, bundle)
                }

                R.id.delete -> {
                    // ÏÇ≠Ï†ú
                    viewModel.fetchDeleteReview(reviewId) { success ->
                        if (success) {
                            navController.popBackStack()
                        } else {
                            showCustomSnackBar(requireContext(), binding.root, "Í≤åÏãúÍ∏Ä ÏÇ≠Ï†úÎ•º Ïã§Ìå® ÌñàÏäµÎãàÎã§. ü•≤")
                        }
                    }
                }
            }
            false
        }
        popupMenu.show()
    }

    private fun timeCalculate(time: String): String {
        // ÏÑúÎ≤ÑÏóêÏÑú Î∞õÏïÑÏò® ÏãúÍ∞ÑÏùÑ ÌååÏã±
        val serverTime = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            LocalDateTime.parse(time, DateTimeFormatter.ISO_DATE_TIME)
        } else {
            // SDK Î≤ÑÏ†ÑÏù¥ O ÎØ∏ÎßåÏùº Í≤ΩÏö∞
            return "ÏãúÍ∞Ñ Ï†ïÎ≥¥Î•º ÏÇ¨Ïö©Ìï† Ïàò ÏóÜÏäµÎãàÎã§."
        }

        // ÌòÑÏû¨ ÏãúÍ∞ÑÏùÑ Íµ¨Ìï®
        val currentTime = LocalDateTime.now()

        // ÏãúÍ∞ÑÏùÑ ÎπÑÍµê ÌïòÏó¨ Ï∞®Ïù¥Î•º Í≥ÑÏÇ∞
        val diffInHours = ChronoUnit.HOURS.between(serverTime, currentTime)

        return if (diffInHours < 24) {
            Log.d(TAG, "timeCalculate: $diffInHours")
            "$diffInHours ÏãúÍ∞Ñ Ï†Ñ"
        } else {
            val dateFormatter = DateTimeFormatter.ofPattern("yyyyÎÖÑ MMÏõî ddÏùº")
            serverTime.format(dateFormatter)
        }
    }

}
