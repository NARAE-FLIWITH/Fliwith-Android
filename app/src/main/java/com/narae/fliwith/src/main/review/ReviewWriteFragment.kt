package com.narae.fliwith.src.main.review

import ReviewWriteImageAdapter
import android.Manifest
import android.content.ActivityNotFoundException
import android.content.Context
import android.content.Intent
import android.net.Uri
import android.os.Bundle
import android.provider.MediaStore
import android.text.Editable
import android.text.TextWatcher
import android.util.Log
import android.view.MenuInflater
import android.view.View
import android.widget.PopupMenu
import androidx.activity.result.PickVisualMediaRequest
import androidx.activity.result.contract.ActivityResultContracts
import androidx.core.content.FileProvider
import androidx.fragment.app.activityViewModels
import androidx.lifecycle.MediatorLiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.lifecycleScope
import com.narae.fliwith.R
import com.narae.fliwith.config.BaseFragment
import com.narae.fliwith.databinding.FragmentReviewWriteBinding
import com.narae.fliwith.src.main.MainActivity
import com.narae.fliwith.src.main.review.models.ReviewInsertRequest
import com.narae.fliwith.src.main.review.models.ReviewPresignedRequest
import com.narae.fliwith.src.main.review.models.ReviewViewModel
import com.narae.fliwith.util.requestCameraPermission
import com.narae.fliwith.util.showCustomSnackBar
import kotlinx.coroutines.launch
import java.io.File
import java.io.FileOutputStream
import java.io.InputStream
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale
import kotlin.coroutines.resume
import kotlin.coroutines.suspendCoroutine

private const val TAG = "ReviewWriteFragment_Ïã∏Ìîº"
class ReviewWriteFragment : BaseFragment<FragmentReviewWriteBinding>(
    FragmentReviewWriteBinding::inflate) {

    private val viewModel: ReviewViewModel by activityViewModels()
    private var reviewId:Int=-1
    private lateinit var imageAdapter: ReviewWriteImageAdapter
    private val imageUrls: MutableList<String> = mutableListOf()
    private val presignedUrls: MutableList<String> = mutableListOf()
    private val _checkSpotId = MutableLiveData<Boolean>(false)
    private val _checkContentLength = MutableLiveData<Boolean>(false)
    private val _checkImageSelect = MutableLiveData<Boolean>(false)

    // Ïπ¥Î©îÎùºÏóêÏÑú ÏÉùÏÑ±Ìïú ÏÇ¨ÏßÑ uri
    private var currentPhotoUri: Uri? = null

    private val _isButtonEnabled = MediatorLiveData<Boolean>().apply {
        addSource(_checkContentLength) { checkButtonEnabled() }
        addSource(_checkSpotId) { checkButtonEnabled() }
        addSource(_checkImageSelect) { checkButtonEnabled() }
    }

    // pickMedia Ìï®Ïàò
    private val pickMedia = registerForActivityResult(ActivityResultContracts.PickMultipleVisualMedia(10)) { uris ->
        if (uris.isNotEmpty()) {
            // uris Î¶¨Ïä§Ìä∏Ïóê Í∞íÏù¥ ÏûàÏùÑ Í≤ΩÏö∞
            val imageUrls = uris.map { uri -> uri.toString() } // UriÎ•º StringÏúºÎ°ú Î≥ÄÌôò
            imageAdapter.setImages(imageUrls)

            viewModel.setSelectedUris(uris)
            viewModel.setIsImageSelect(true)
        }
    }

    // Ïπ¥Î©îÎùº Ïï±ÏùÑ ÌÜµÌï¥ ÏÇ¨ÏßÑÏùÑ Ï¥¨ÏòÅÌïú ÌõÑÏùò Í≤∞Í≥ºÎ•º Ï≤òÎ¶¨
    private val takePictureLauncher = registerForActivityResult(ActivityResultContracts.TakePicture()) { success ->
        if (success) {
            // ÏÑ±Í≥µ ÌñàÏùÑ Îïå
            imageAdapter.setImages(listOf(currentPhotoUri.toString()))

            viewModel.setSelectedUris(listOf(currentPhotoUri!!))
            viewModel.setIsImageSelect(true)
        } else {
            //Ïã§Ìå® ÌñàÏùÑ Îïå
            Log.d(TAG, "camera ÏÇ¨ÏßÑ Í∞ÄÏ†∏ Ïò§Í∏∞ Ïã§Ìå®")
        }
    }

    // Ïπ¥Î©îÎùº Í∂åÌïú ÏàòÏ†ï launcher
    private val cameraPermission = registerForActivityResult(ActivityResultContracts.RequestPermission()) {
        if(it) {
            // ÏÑ±Í≥µ ÌñàÏùÑ Îïå
            takePickture()
        } else {
            Log.d(TAG, "camera Í∂åÌïú Î∞õÏïÑ Ïò§Í∏∞ Ïã§Ìå®")
        }
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        // Î∞õÏïÑÏò® reviewId
        reviewId = arguments?.getInt("reviewId") ?: -1

        // RecyclerView ÏÑ§Ï†ï
        imageAdapter = ReviewWriteImageAdapter(requireContext(), imageUrls)
        binding.reviewWriteImageRv.adapter = imageAdapter

        // ÏàòÏ†ï
        if(reviewId!=-1) {
            binding.reviewWriteBtn.isEnabled = true
            // ÏàòÏ†ï Í∏∞Î≥∏ Îç∞Ïù¥ÌÑ∞ Ïú†ÏßÄ ÏãúÏºú Ï£ºÍ∏∞
            binding.reviewWriteImageFrame.visibility = View.VISIBLE
            // Ïû•ÏÜå
            binding.reviewWriteEt.setText(viewModel.reviewSpotName.value)
            // Í∏∞Ï°¥Ïóê ÏÑúÎ≤ÑÏóêÏÑú Î∞õÏïÑÏôîÎçò Îç∞Ïù¥ÌÑ∞Î•º Í∞ÄÏ†∏ÏôÄÏÑú Ïú†ÏßÄ ÏãúÏºú Ï§òÏïº ÌïòÎäî Í≤ÉÏûÑ
            imageAdapter.setImages(viewModel.reviewImageUrls.value!!)
            // reviewImageUrlsÏùò Í∞Å URLÏùÑ uploadImageUrlsÏóê Ï∂îÍ∞Ä
            viewModel.reviewImageUrls.value?.forEach { url ->
                viewModel.addUploadImageUrl(url)
            }
            // ÌõÑÍ∏∞
            binding.reviewWriteComment.setText(viewModel.reviewWriteContent.value)
            binding.reviewWriteCommentTv.text = "${viewModel.reviewWriteContent.value?.length}Ïûê / ÏµúÏÜå 20Ïûê"
            // contendId
            Log.d(TAG, "onViewCreated: Ïó¨Í∏∞Îäî ÏàòÏ†ïÏù¥Îã§. ${viewModel.reviewSpotContentId.value}")
        }else {
            _isButtonEnabled.observe(viewLifecycleOwner) { isEnabled ->
                if(isEnabled) {
                    Log.d(TAG, "onViewCreated: Î≤ÑÌäº ÏÉÅÌÉú - $isEnabled")
                    binding.reviewWriteBtn.isEnabled = true
                }else {
                    binding.reviewWriteBtn.isEnabled = false
                }
            }
        }

        binding.reviewWriteBtn.setOnClickListener {
            showCustomSnackBar(requireContext(), binding.root, "Í≤åÏãúÍ∏Ä ÏóÖÎ°úÎìú Ï§ë ÏûÖÎãàÎã§! Ï°∞Í∏àÎßå Í∏∞Îã§Î†§Ï£ºÏÑ∏Ïöî üòÅ")
            viewModel.selectedUris?.let { uris ->
                uploadImagesSequentially(requireContext(), uris) { success ->
                    if (success) {
                        // Proceed with posting the review data
                        val request = ReviewInsertRequest(
                            viewModel.reviewSpotContentId.value!!,
                            viewModel.reviewWriteContent.value!!,
                            viewModel.uploadImageUrls.value!!)

                        postReviewData(request)
                        viewModel.clearData()
                        // ÏóÖÎ°úÎìú ÏôÑÎ£å ÌõÑ ÏÑ±Í≥µ Î©îÏãúÏßÄ ÌëúÏãú
                        showCustomSnackBar(requireContext(), binding.root, "Í≤åÏãúÍ∏ÄÏù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏóÖÎ°úÎìúÎêòÏóàÏäµÎãàÎã§! üéâ")
                    } else {
                        // ÏóÖÎ°úÎìú Ïã§Ìå® Ïãú Î©îÏãúÏßÄ ÌëúÏãú
                        showCustomSnackBar(requireContext(), binding.root, "Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìúÏóê Ïã§Ìå® ÌñàÏäµÎãàÎã§. ü•≤")
                    }
                }
            } ?: run {
                // If there are no images to upload, just post the review data
                val request = ReviewInsertRequest(
                    viewModel.reviewSpotContentId.value!!,
                    viewModel.reviewWriteContent.value!!,
                    viewModel.uploadImageUrls.value!!)

                postReviewData(request)
                viewModel.clearData()
                // ÏóÖÎ°úÎìú ÏôÑÎ£å ÌõÑ ÏÑ±Í≥µ Î©îÏãúÏßÄ ÌëúÏãú
                showCustomSnackBar(requireContext(), binding.root, "Í≤åÏãúÍ∏ÄÏù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏóÖÎ°úÎìúÎêòÏóàÏäµÎãàÎã§! üéâ")
            }
        }

        // Ïù¥ÎØ∏ÏßÄ Í∏∞Î≥∏ frame
        binding.reviewWriteImageFrame.setOnClickListener {
            showPopUp(binding.reviewWriteImageFrame)
        }

        // ÏßÄÏó≠ ÏûëÏÑ± Î≤ÑÌäºÏùÑ ÎàÑÎ•¥Î©¥
        binding.reviewWriteEtLayout.setOnClickListener {
            // Í≤ÄÏÉâÏ∞Ω ÌôîÎ©¥ ÏúºÎ°ú Ïù¥Îèô
            navController.navigate(R.id.action_reviewWriteFragment_to_reviewSpotNameFragment)
        }

        // ÎÇ¥Í∞Ä ÏÑ†ÌÉùÌïú spotName
        binding.reviewWriteEt.setText(viewModel.reviewSpotName.value)
        Log.d(TAG, "onViewCreated review write fragment : ${viewModel.reviewSpotName.value}")

        // EditTextÏóê TextWatcher ÏÑ§Ï†ï
        binding.reviewWriteComment.addTextChangedListener(object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}

            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}

            override fun afterTextChanged(s: Editable?) {
                viewModel.setReviewWriteContent(s.toString())
                binding.reviewWriteCommentTv.text = "${viewModel.reviewWriteContent.value?.length}Ïûê / ÏµúÏÜå 20Ïûê"
            }
        })

        viewModel.reviewWriteContent.observe(viewLifecycleOwner) { content ->
            _checkContentLength.value = content != null && content.length >= 20
        }

        viewModel.reviewSpotContentId.observe(viewLifecycleOwner) { id ->
            _checkSpotId.value = id != null
        }

        viewModel.isImageSelect.observe(viewLifecycleOwner) { check ->
            _checkImageSelect.value = check != null
        }

        binding.reviewWriteBackIcon.setOnClickListener {
            navController.popBackStack()
        }

    }

    private fun checkButtonEnabled() {
        _isButtonEnabled.value = _checkContentLength.value == true &&
                _checkSpotId.value == true && _checkImageSelect.value == true
        Log.d(TAG, "_isButtonEnabled.value: ${_isButtonEnabled.value}")
        Log.d(TAG, "_checkContentLength.value: ${_checkContentLength.value}")
        Log.d(TAG, "_checkSpotId.value: ${_checkSpotId.value}")
        Log.d(TAG, "_checkImageSelect.value: ${_checkImageSelect.value}")
    }

    fun postReviewData(request : ReviewInsertRequest) {
        viewModel.setReviewInsertRequest(request)
        if(reviewId==-1) {
            viewModel.fetchInsert(viewModel.reviewInsertRequest.value) { success ->
                if (success) {
                    // ÏûëÏÑ±ÌïòÍ≥† Î¶¨Î∑∞ ÌôîÎ©¥ÏúºÎ°ú Îã§Ïãú Ïù¥Îèô
                    navController.navigate(R.id.action_reviewWriteFragment_to_menu_main_btm_nav_review)
                } else {
                    // ÏóêÎü¨ Ï≤òÎ¶¨
                    Log.d(TAG, "postReviewData: Î¶¨Î∑∞ ÏûëÏÑ± Î™ªÌï¥Îî∞!")
                }
            }
        }else {
            viewModel.fetchUpdate(reviewId, viewModel.reviewInsertRequest.value) { success ->
                if (success) {
                    // ÏûëÏÑ±ÌïòÍ≥† Î¶¨Î∑∞ ÌôîÎ©¥ÏúºÎ°ú Îã§Ïãú Ïù¥Îèô
                    navController.popBackStack()
                } else {
                    // ÏóêÎü¨ Ï≤òÎ¶¨
                    Log.d(TAG, "postReviewData: Î¶¨Î∑∞ ÏàòÏ†ï Î™ªÌï¥Îî∞!")
                }
            }
        }

    }

    fun showPopUp(view: View) {
        val popupMenu = PopupMenu(requireContext(), view, 0, 0, R.style.CustomPopupMenu)
        val inflater: MenuInflater = popupMenu.menuInflater
        inflater.inflate(R.menu.menu_review_write_popup, popupMenu.menu)

        try {
            val fields = popupMenu::class.java.declaredFields
            for (field in fields) {
                if ("mPopup" == field.name) {
                    field.isAccessible = true
                    val menuPopupHelper = field.get(popupMenu)
                    val classPopupHelper = Class.forName(menuPopupHelper.javaClass.name)
                    val setForceIcons = classPopupHelper.getMethod("setForceShowIcon", Boolean::class.javaPrimitiveType)
                    setForceIcons.invoke(menuPopupHelper, true)
                    break
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }

        popupMenu.setOnMenuItemClickListener { menuItem ->
            when (menuItem.itemId) {
                R.id.gallery_menu -> {
                    // Í∞§Îü¨Î¶¨ ÏÑ†ÌÉù
                    presignedUrls.clear()
                    viewModel.clearUploadImageUrls()
                    photoPicker()
                }
                R.id.camera_menu -> {
                    // ÏÇ¨ÏßÑ Ï∞çÍ∏∞
                    presignedUrls.clear()
                    viewModel.clearUploadImageUrls()
                    requireContext().requestCameraPermission(
                        onGrant = {
                            takePickture()
                        },
                        onDenied = {
                            cameraPermission.launch(Manifest.permission.CAMERA)
                        }
                    )
                }
            }
            false
        }
        popupMenu.show()
    }

    fun photoPicker() {
        // Ïù¥ÎØ∏ÏßÄÎßå
        pickMedia.launch(PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageOnly))
    }

    fun takePickture() {
        val takePictureIntent = Intent(MediaStore.ACTION_IMAGE_CAPTURE)
        // Ïπ¥Î©îÎùº Ïï±Ïù¥ ÏÑ§Ïπò ÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏
        if (takePictureIntent.resolveActivity(requireContext().packageManager) != null) {
            try {
                // Ïù¥ÎØ∏ÏßÄ ÌååÏùº ÏÉùÏÑ±
                val photoFile: File? = createImageFile()
                photoFile?.let {
                    // FileProviderÎ•º ÌÜµÌï¥ ÏïàÏ†ÑÌïòÍ≤å Uri Í≥µÏú†
                    currentPhotoUri = FileProvider.getUriForFile(
                        requireContext(),
                        "${requireContext().packageName}.provider",
                        it
                    )
                    takePictureLauncher.launch(currentPhotoUri)
                    Log.d(TAG, "takePickture: ${currentPhotoUri}")
                }
            } catch (e: Exception) {
                // ÏòàÏô∏ Ï≤òÎ¶¨ (Ïπ¥Î©îÎùº Ïï±Ïù¥ ÏÑ§ÏπòÎêòÏñ¥ ÏûàÏßÄ ÏïäÏùÄ Í≤ΩÏö∞ Ìè¨Ìï®)
                e.printStackTrace()
            }
        }
    }

    private fun createImageFile(): File? {
        val timestamp: String = SimpleDateFormat("yyyyMMdd_HHmmss", Locale.US).format(Date())
        val storageDir: File? = requireContext().externalCacheDir
        return File.createTempFile(
            "image_file_$timestamp", /* prefix */
            ".jpg", /* suffix */
            storageDir /* directory */
        )
    }

    fun uploadImagesSequentially(context: Context, uris: List<Uri>, callback: (Boolean) -> Unit) {
        lifecycleScope.launch {
            var allSuccess = true
            for (uri in uris) {
                val file = viewModel.uriToFile(context, uri)
                if (file != null) {
                    val mimeType = viewModel.getMimeType(context, uri)
                    if (mimeType != null) {
                        // Presigned URL Î∞úÍ∏â ÏöîÏ≤≠
                        val success = fetchPresignedReviewAwait(viewModel.getFileExtension(context, uri))
                        if (success) {
                            val presignedUrl = presignedUrls.last()
                            val uploadSuccess = uploadImageAWSAwait(presignedUrl, file, mimeType)
                            if (!uploadSuccess) {
                                allSuccess = false
                                break
                            } else {
                                Log.d(TAG, "Image uploaded successfully")
                            }
                        } else {
                            allSuccess = false
                            break
                        }
                    } else {
                        Log.d(TAG, "Failed to get MIME type for image: $uri")
                        allSuccess = false
                        break
                    }
                } else {
                    Log.d(TAG, "Failed to convert URI to file: $uri")
                    allSuccess = false
                    break
                }
            }
            Log.d(TAG, "uploadImagesSequentially: ${viewModel.uploadImageUrls.value}")
            callback(allSuccess)
        }
    }

    suspend fun fetchPresignedReviewAwait(fileExtension: String): Boolean {
        return suspendCoroutine { continuation ->
            viewModel.fetchPresignedReview(ReviewPresignedRequest(fileExtension)) { success, presignedData ->
                if (success && presignedData != null) {
                    Log.d(TAG, "fetchPresignedReviewAwait: ÌîÑÎ¶¨ÏÇ¨Ïù∏Îìú url Î∞úÍ∏â ÏôÑÎ£å")
                    presignedUrls.add(presignedData.presignedUrl)
                    viewModel.addUploadImageUrl(presignedData.imageUrl)
                    continuation.resume(true)
                } else {
                    Log.d(TAG, "Failed to get presigned URL")
                    continuation.resume(false)
                }
            }
        }
    }

    suspend fun uploadImageAWSAwait(presignedUrl: String, file: File, mimeType: String): Boolean {
        return suspendCoroutine { continuation ->
            viewModel.uploadImageAWS(presignedUrl, file, mimeType) { success ->
                continuation.resume(success)
            }
        }
    }

}